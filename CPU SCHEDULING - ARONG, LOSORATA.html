<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CPU SCHEDULING SIMULATOR</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #0a1a3b; /* Indigo dark background */
      margin: 0;
      padding: 20px;
      color: #ff69b4; /* Pink text */
    }
    h2 {
      text-align: center;
      color: #ff69b4; /* Pink */
    }
    .container {
      max-width: 1200px;
      margin: auto;
      background-color: #13294b; /* Indigo container bg */
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(255, 105, 180, 0.3); /* Pink glow */
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 30px;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    label {
      font-weight: bold;
      display: block;
      margin: 10px 0 5px;
      color: #ffb6c1; /* light pink */
    }
    input, select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ff69b4; /* pink border */
      border-radius: 5px;
      background-color: #1a2d5c; /* dark indigo input bg */
      color: #ffb6c1; /* light pink text */
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      background-color: #1a2d5c;
      color: #ffb6c1;
    }
    th, td {
      padding: 10px;
      border: 1px solid #ff69b4;
      text-align: center;
    }
    .btn {
      padding: 10px 15px;
      margin-top: 15px;
      margin-right: 10px;
      font-weight: bold;
      background-color: #ff69b4;
      color: #0a1a3b;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .btn:hover {
      background-color: #ff85c1;
    }
    .gantt-chart-box {
      background-color: #1e345d;
      padding: 10px 10px 30px 10px; /* Extra bottom padding for time labels */
      border-radius: 5px;
      border: 1px solid #ff69b4;
      margin-top: 20px;
      height: 80px;
      width: 1200px; /* Fixed width for the Gantt Chart */
      max-width: 1200px;
      overflow-x: auto;
      overflow-y: hidden;
      white-space: nowrap;
      color: #ffb6c1;
      box-sizing: border-box;
      position: relative;
    }
    .gantt-bar {
      display: inline-block;
      background-color: #ff69b4; /* Default, will be overridden inline */
      color: #0a1a3b;
      padding: 5px 8px;
      margin-right: 2px;
      border-radius: 3px;
      font-weight: bold;
      min-width: 60px;
      box-sizing: border-box;
      text-align: center;
      white-space: nowrap;
      vertical-align: middle;
      position: relative;
    }
    .gantt-time-label {
      position: absolute;
      bottom: 0;
      font-size: 13px;
      color: #ffd700;
      font-weight: bold;
      white-space: nowrap;
      transform: none;
      pointer-events: none;
      text-align: right;
    }
    .gantt-bar-wrapper {
      display: inline-block;
      position: relative;
      vertical-align: top;
      height: 100%;
      min-width: 60px;
      box-sizing: border-box;
    }
    .gantt-chart-box::-webkit-scrollbar {
      height: 8px;
      background: #13294b;
    }
    .gantt-chart-box::-webkit-scrollbar-thumb {
      background: #ff69b4;
      border-radius: 4px;
    }
    .current-process-bar {
      margin-top: 20px;
    }
    .bar-label {
      margin-bottom: 5px;
      font-weight: bold;
      color: #ffb6c1;
    }
    .bar {
      width: 100%;
      height: 20px;
      margin-bottom: 10px;
      background: linear-gradient(to right, #ff69b4, #4b8cf5);
      border-radius: 10px;
      color: white;
      font-weight: bold;
      line-height: 20px;
      text-align: center;
    }
    .radio-group {
      display: flex;
      gap: 20px;
      align-items: center;
      color: #ffb6c1;
    }
    .gantt-box {
      min-width: 60px; /* Adjust based on max label length */
      padding: 4px 8px;
      white-space: nowrap;
      overflow: visible;
      text-align: center;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>CPU SCHEDULING SIMULATOR</h2>
    <div class="row">
      <div style="flex: 1 1 45%">
        <label for="numProcesses">Number of Processes:</label>
        <input type="number" id="numProcesses" min="1" value="">

        <div class="radio-group">
          <label><input type="radio" name="inputType" value="manual" checked> Manual Input</label>
          <label><input type="radio" name="inputType" value="random"> Random Input</label>
        </div>

        <table id="inputTable">
          <thead><tr><th>PID</th><th>Arrival Time</th><th>Burst Time</th></tr></thead>
          <tbody></tbody>
        </table>

        <label>Select your chosen Algorithm:</label>
        <select id="algorithm">
          <option value="fcfs">First-In First-Out (FCFS)</option>
          <option value="sjf">Shortest Job First (SJF – Non-Preemptive)</option>
          <option value="srtf">Shortest Remaining Time First (SRTF – Preemptive)</option>
          <option value="rr">Round Robin</option>
          <option value="mlfq">Multilevel Feedback Queue (MLFQ)</option>
        </select>

        <label>Time Quantum for Round Robin:</label>
        <input type="number" id="rrQuantum" placeholder="RR Quantum" value="">

        <label>Time Quantums for MLFQ:</label>
        <input type="number" id="q0" placeholder="Q0 Quantum" value="">
        <input type="number" id="q1" placeholder="Q1 Quantum" value="">
        <input type="number" id="q2" placeholder="Q2 Quantum" value="">
        <input type="number" id="q3" placeholder="Q3 Quantum" value="">

        <label>Allotment Times for MLFQ:</label>
        <input type="number" id="a0" placeholder="Q0 Allotment" value="">
        <input type="number" id="a1" placeholder="Q1 Allotment" value="">
        <input type="number" id="a2" placeholder="Q2 Allotment" value="">
        <input type="number" id="a3" placeholder="Q3 Allotment" value="">

        <div>
          <button class="btn" onclick="runSimulation()">Run Simulation</button>
          <button class="btn" onclick="stopSimulation()">Stop</button>
          <button class="btn" onclick="resetSimulation()">Start another Simulation</button>
        </div>
        <div style="margin-top: 15px;">
          <label>Context Switch Delay (ms):</label>
          <input type="number" id="contextSwitchDelay" placeholder="e.g. 200" value="0" min="0" style="width: 120px; display: inline-block;">
        </div>
        <div style="margin-top: 15px;">
          <label>Export Results:</label>
          <select id="exportFormat">
            <option value="csv">CSV</option>
            <option value="txt">Plain Text</option>
            <option value="img">Image (Gantt Chart)</option>
          </select>
          <button class="btn" onclick="exportResults()">Export</button>
        </div>
      </div>

      <div style="flex: 1 1 45%">
        <label>Gantt Chart Output:</label>
        <div class="gantt-chart-box">
          <div id="ganttChart"></div>
        </div>

        <h3>Current Process</h3>
        <div class="current-process-bar" id="currentProcessBar"></div>

        <table id="outputTable">
          <thead><tr><th>PID</th><th>AT</th><th>BT</th><th>CT</th><th>TAT</th><th>RT</th></tr></thead>
          <tbody></tbody>
        </table>

        <p><strong>Average Turnaround Time:</strong> <span id="avgTAT">0</span></p>
        <p><strong>Average Response Time:</strong> <span id="avgRT">0</span></p>
      </div>
    </div>
    <h3>Execution Log</h3>
    <div id="execLog" style="background:#1e345d; color:#ffb6c1; padding:10px; border-radius:5px; height:100px; overflow-y:auto; font-size:13px;"></div>
  </div>

  <script>
    let simulationStopped = false;
    let lastSimulationData = null; // Store last simulation results for export
    let storedRandomValues = []; // Store random values to prevent changes
    function getColorForPID(pid) {
      // Assign a distinct color for each PID using a color palette
      const ganttColors = [
        "#ff69b4", "#4b8cf5", "#ffd700", "#32cd32", "#ff4500", "#8a2be2", "#00ced1", "#ff6347", "#20b2aa", "#ffa500",
        "#e75480", "#4682b4", "#bada55", "#e9967a", "#9932cc", "#40e0d0", "#ffb347", "#b22222", "#5f9ea0", "#ff7f50"
      ];
      const num = parseInt(pid.replace(/\D/g, "")) || 0;
      return ganttColors[(num - 1) % ganttColors.length];
    }
    function logExec(msg) {
      const logPanel = document.getElementById("execLog");
      logPanel.innerHTML += msg + "<br>";
      logPanel.scrollTop = logPanel.scrollHeight;
    }

    function toggleInputType() {
      const type = document.querySelector('input[name="inputType"]:checked').value;
      const tbody = document.querySelector("#inputTable tbody");
      tbody.innerHTML = "";
      const num = parseInt(document.getElementById("numProcesses").value) || 0;
      
      // Generate new random values only if switching to random mode or if values don't exist
      if (type === "random" && (storedRandomValues.length !== num || storedRandomValues.length === 0)) {
        storedRandomValues = [];
        for (let i = 0; i < num; i++) {
          storedRandomValues.push({
            at: Math.floor(Math.random() * 10),
            bt: Math.floor(Math.random() * 10) + 1
          });
        }
      }
      
      for (let i = 0; i < num; i++) {
        const row = document.createElement("tr");
        const pid = "P" + (i + 1);
        let at, bt;
        
        if (type === "random") {
          at = storedRandomValues[i] ? storedRandomValues[i].at : 0;
          bt = storedRandomValues[i] ? storedRandomValues[i].bt : 1;
        } else {
          at = "";
          bt = "";
        }
        
        row.innerHTML = `
          <td><input type="text" value="${pid}" disabled></td>
          <td><input type="number" value="${at}" ${type === "manual" ? "" : "disabled"}></td>
          <td><input type="number" value="${bt}" ${type === "manual" ? "" : "disabled"}></td>
        `;
        tbody.appendChild(row);
      }
    }

    function runSimulation() {
      simulationStopped = false;
      lastSimulationData = null;
      const gantt = document.getElementById("ganttChart");
      const current = document.getElementById("currentProcessBar");
      const execLog = document.getElementById("execLog");
      gantt.innerHTML = "";
      current.innerHTML = "";
      execLog.innerHTML = "";
      const outputTable = document.querySelector("#outputTable tbody");
      outputTable.innerHTML = "";
      document.getElementById("avgTAT").textContent = "0";
      document.getElementById("avgRT").textContent = "0";

      const rows = document.querySelectorAll("#inputTable tbody tr");
      let processes = [];

      rows.forEach((row, i) => {
        const pid = row.children[0].children[0].value;
        const at = parseInt(row.children[1].children[0].value);
        const bt = parseInt(row.children[2].children[0].value);
        processes.push({ pid, at, bt, remaining: bt, ct: 0 });
      });

      processes.sort((a, b) => a.at - b.at);
      const algorithm = document.getElementById("algorithm").value;
      const contextSwitchDelay = parseInt(document.getElementById("contextSwitchDelay").value) || 0;

      if (algorithm === "fcfs") {
        runFCFS(processes, contextSwitchDelay);
      } else if (algorithm === "sjf") {
        runSJF(processes, contextSwitchDelay);
      } else if (algorithm === "srtf") {
        runSRTF(processes, contextSwitchDelay);
      } else if (algorithm === "rr") {
        const quantum = parseInt(document.getElementById("rrQuantum").value) || 1;
        runRR(processes, quantum, contextSwitchDelay);
      } else if (algorithm === "mlfq") {
        const q0 = parseInt(document.getElementById("q0").value) || 2;
        const q1 = parseInt(document.getElementById("q1").value) || 4;
        const q2 = parseInt(document.getElementById("q2").value) || 8;
        const q3 = parseInt(document.getElementById("q3").value) || 16;
        const a0 = parseInt(document.getElementById("a0").value) || q0;
        const a1 = parseInt(document.getElementById("a1").value) || q1;
        const a2 = parseInt(document.getElementById("a2").value) || q2;
        const a3 = parseInt(document.getElementById("a3").value) || q3;
        runMLFQ(processes, [q0, q1, q2, q3], [a0, a1, a2, a3], contextSwitchDelay);
      } else {
        alert("Unknown algorithm selected.");
      }
    }

    function addGanttBlock(gantt, pid, bt, endTime, queueLabel) {
      const ganttWrapper = document.createElement("div");
      ganttWrapper.className = "gantt-bar-wrapper";
      // Calculate width: proportional to burst time, but at least enough for label
      const label = queueLabel ? pid + queueLabel : pid;
      const charWidth = 10; // px per character (approx)
      const minWidth = Math.max(60, label.length * charWidth + 20); // 20px padding
      const width = Math.max(bt * 30, minWidth);
      ganttWrapper.style.width = width + "px";
      ganttWrapper.style.position = "relative";
      ganttWrapper.style.display = "inline-block";
      ganttWrapper.style.verticalAlign = "top";
      const ganttBlock = document.createElement("div");
      ganttBlock.className = "gantt-bar";
      ganttBlock.textContent = label;
      ganttBlock.style.backgroundColor = pid === 'IDLE' ? '#444' : getColorForPID(pid);
      ganttBlock.style.width = "100%";
      ganttWrapper.appendChild(ganttBlock);
      // Time label at right edge, below the block
      const timeLabel = document.createElement("div");
      timeLabel.className = "gantt-time-label";
      timeLabel.textContent = endTime;
      timeLabel.style.right = "0";
      timeLabel.style.left = "auto";
      timeLabel.style.width = "max-content";
      timeLabel.style.position = "absolute";
      timeLabel.style.bottom = "-18px";
      timeLabel.style.transform = "none";
      timeLabel.style.textAlign = "right";
      ganttWrapper.appendChild(timeLabel);
      gantt.appendChild(ganttWrapper);
    }

    function runFCFS(processes, contextSwitchDelay) {
      const gantt = document.getElementById("ganttChart");
      const current = document.getElementById("currentProcessBar");
      const outputTable = document.querySelector("#outputTable tbody");
      let time = 0;
      let index = 0;
      let queue = [];
      let totalTAT = 0;
      let totalRT = 0;
      let results = [];
      function scheduleNext() {
        if (simulationStopped) return;
        while (index < processes.length && processes[index].at <= time) {
          queue.push(processes[index]);
          index++;
        }
        if (queue.length === 0 && index < processes.length) {
          time++;
          setTimeout(scheduleNext, 500);
          return;
        }
        if (queue.length === 0 && index >= processes.length) {
          document.getElementById("avgTAT").textContent = (totalTAT / processes.length).toFixed(2);
          document.getElementById("avgRT").textContent = (totalRT / processes.length).toFixed(2);
          lastSimulationData = {
            gantt: gantt.innerHTML,
            table: results,
            avgTAT: (totalTAT / processes.length).toFixed(2),
            avgRT: (totalRT / processes.length).toFixed(2)
          };
          return;
        }
        const p = queue.shift();
        const startTime = time;
        const endTime = time + p.bt;
        p.ct = endTime;
        p.startTime = startTime;
        const tat = p.ct - p.at;
        const rt = p.startTime - p.at;
        totalTAT += tat;
        totalRT += rt;
        addGanttBlock(gantt, p.pid, p.bt, endTime);
        logExec(`Process ${p.pid} started at time ${startTime}, completed at ${endTime}`);
        current.innerHTML = "";
        const label = document.createElement("div");
        label.className = "bar-label";
        label.textContent = p.pid;
        const bar = document.createElement("div");
        bar.className = "bar";
        bar.textContent = p.pid;
        current.appendChild(label);
        current.appendChild(bar);
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${p.pid}</td>
          <td>${p.at}</td>
          <td>${p.bt}</td>
          <td>${p.ct}</td>
          <td>${tat}</td>
          <td>${rt}</td>
        `;
        outputTable.appendChild(row);
        results.push({pid: p.pid, at: p.at, bt: p.bt, ct: p.ct, tat, rt});
        time = endTime;
        if (queue.length > 0 || index < processes.length) {
          time += contextSwitchDelay / 1000; // Add context switch delay in seconds
        }
        setTimeout(scheduleNext, 1000 + contextSwitchDelay);
      }
      scheduleNext();
    }

  function runSJF(processes, contextSwitchDelay) {
  const gantt = document.getElementById("ganttChart");
  const current = document.getElementById("currentProcessBar");
  const outputTable = document.querySelector("#outputTable tbody");

  let time = 0;
  let completed = 0;
  let totalTAT = 0;
  let totalRT = 0;
  const n = processes.length;
  let isDone = Array(n).fill(false);
  let results = [];

  function scheduleNext() {
    if (simulationStopped) return;

    let idx = -1;
    let minBT = Infinity;

    // Find the shortest job among those that have arrived
    for (let i = 0; i < n; i++) {
      if (!isDone[i] && processes[i].at <= time && processes[i].bt < minBT) {
        minBT = processes[i].bt;
        idx = i;
      }
    }

    // If no process is ready, just wait (no idle block)
if (idx === -1) {
  time++;
  setTimeout(scheduleNext, 500);
  return;
}

    const p = processes[idx];
    const startTime = time;
    const endTime = startTime + p.bt;

    // Compute results
    p.ct = endTime;
    p.startTime = startTime;
    const tat = p.ct - p.at;
    const rt = p.startTime - p.at;
    totalTAT += tat;
    totalRT += rt;
    isDone[idx] = true;
    completed++;

    // Draw Gantt chart
    addGanttBlock(gantt, p.pid, p.bt, endTime);
    logExec(`Process ${p.pid} started at time ${startTime}, completed at ${endTime}`);

    // Update current process bar
    current.innerHTML = "";
    const label = document.createElement("div");
    label.className = "bar-label";
    label.textContent = p.pid;
    const bar = document.createElement("div");
    bar.className = "bar";
    bar.textContent = p.pid;
    current.appendChild(label);
    current.appendChild(bar);

    // Output table
    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${p.pid}</td>
      <td>${p.at}</td>
      <td>${p.bt}</td>
      <td>${p.ct}</td>
      <td>${tat}</td>
      <td>${rt}</td>
    `;
    outputTable.appendChild(row);
    results.push({ pid: p.pid, at: p.at, bt: p.bt, ct: p.ct, tat, rt });

    // Move time and continue
    time = endTime;
    if (completed < n) {
      time += contextSwitchDelay / 1000;
    }

    if (completed === n) {
      document.getElementById("avgTAT").textContent = (totalTAT / n).toFixed(2);
      document.getElementById("avgRT").textContent = (totalRT / n).toFixed(2);
      lastSimulationData = {
        gantt: gantt.innerHTML,
        table: results,
        avgTAT: (totalTAT / n).toFixed(2),
        avgRT: (totalRT / n).toFixed(2)
      };
    } else {
      setTimeout(scheduleNext, 1000 + contextSwitchDelay);
    }
  }

  scheduleNext();
}

    function runSRTF(processes, contextSwitchDelay) {
      const gantt = document.getElementById("ganttChart");
      const current = document.getElementById("currentProcessBar");
      const outputTable = document.querySelector("#outputTable tbody");
      let n = processes.length;
      let time = 0;
      let completed = 0;
      let totalTAT = 0;
      let totalRT = 0;
      let isStarted = Array(n).fill(false);
      let isDone = Array(n).fill(false);
      let results = [];
      let lastPid = null;
      let lastBlock = null;

      // Helper to compare PIDs (assume format 'P1', 'P2', ...)
      function pidToNum(pid) {
        return parseInt(pid.replace(/\D/g, "")) || 0;
      }

      function scheduleNext() {
        if (simulationStopped) return;
        // Find all ready processes (arrived, not done, remaining > 0)
        let ready = [];
        for (let i = 0; i < n; i++) {
          if (!isDone[i] && processes[i].at <= time && processes[i].remaining > 0) {
            ready.push(i);
          }
        }
        if (ready.length === 0) {
          if (completed === n) {
            document.getElementById("avgTAT").textContent = (totalTAT / n).toFixed(2);
            document.getElementById("avgRT").textContent = (totalRT / n).toFixed(2);
            lastSimulationData = {
              gantt: gantt.innerHTML,
              table: results,
              avgTAT: (totalTAT / n).toFixed(2),
              avgRT: (totalRT / n).toFixed(2)
            };
            return;
          }
          // --- IDLE handling: advance to next arrival ---
          // Find the next arrival time for any process not yet completed
          let nextArrival = Infinity;
          for (let i = 0; i < n; i++) {
            if (!isDone[i] && processes[i].at > time) {
              nextArrival = Math.min(nextArrival, processes[i].at);
            }
          }
          if (nextArrival === Infinity) {
            // No more arrivals, just increment time
            time++;
            setTimeout(scheduleNext, 200);
            return;
          }
          // Record IDLE period in Gantt chart
          const idleLength = nextArrival - time;
          addGanttBlock(gantt, 'IDLE', idleLength, nextArrival);
          logExec(`CPU IDLE from time ${time} to ${nextArrival}`);
          current.innerHTML = "";
          time = nextArrival;
          setTimeout(scheduleNext, 300);
          return;
        }
        // Sort ready processes by remaining time, then arrival time, then PID
        ready.sort((ia, ib) => {
          const a = processes[ia];
          const b = processes[ib];
          if (a.remaining !== b.remaining) return a.remaining - b.remaining;
          if (a.at !== b.at) return a.at - b.at;
          return pidToNum(a.pid) - pidToNum(b.pid);
        });
        const idx = ready[0];
        const p = processes[idx];
        // Mark first start time for response time
        if (!isStarted[idx]) {
          p.startTime = time;
          isStarted[idx] = true;
          logExec(`Process ${p.pid} started at time ${time}`);
        } else if (lastPid !== p.pid) {
          logExec(`Process ${lastPid} preempted at time ${time}, ${p.pid} started`);
        }
        // Gantt chart block logic
        if (lastPid !== p.pid) {
          if (lastBlock) {
            lastBlock.querySelector('.gantt-time-label').textContent = time;
          }
          const ganttWrapper = document.createElement("div");
          ganttWrapper.className = "gantt-bar-wrapper";
          ganttWrapper.style.width = "30px";
          ganttWrapper.style.position = "relative";
          ganttWrapper.style.display = "inline-block";
          ganttWrapper.style.verticalAlign = "top";
          const ganttBlock = document.createElement("div");
          ganttBlock.className = "gantt-bar";
          ganttBlock.textContent = p.pid;
          ganttBlock.style.backgroundColor = getColorForPID(p.pid);
          ganttBlock.style.width = "100%";
          ganttWrapper.appendChild(ganttBlock);
          // Time label at right edge, initially empty, will be set on preemption or completion
          const timeLabel = document.createElement("div");
          timeLabel.className = "gantt-time-label";
          timeLabel.textContent = "";
          timeLabel.style.right = "0";
          timeLabel.style.left = "auto";
          timeLabel.style.width = "max-content";
          timeLabel.style.position = "absolute";
          timeLabel.style.bottom = "-18px";
          timeLabel.style.transform = "none";
          timeLabel.style.textAlign = "right";
          ganttWrapper.appendChild(timeLabel);
          gantt.appendChild(ganttWrapper);
          lastPid = p.pid;
          lastBlock = ganttWrapper;
        }
        // Update current process display
        current.innerHTML = "";
        const label = document.createElement("div");
        label.className = "bar-label";
        label.textContent = p.pid;
        const bar = document.createElement("div");
        bar.className = "bar";
        bar.textContent = p.pid;
        current.appendChild(label);
        current.appendChild(bar);
        // Execute for 1 time unit
        p.remaining--;
        if (p.remaining === 0) {
          p.ct = time + 1;
          const tat = p.ct - p.at;
          const rt = p.startTime - p.at;
          totalTAT += tat;
          totalRT += rt;
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${p.pid}</td>
            <td>${p.at}</td>
            <td>${p.bt}</td>
            <td>${p.ct}</td>
            <td>${tat}</td>
            <td>${rt}</td>
          `;
          outputTable.appendChild(row);
          isDone[idx] = true;
          completed++;
          logExec(`Process ${p.pid} completed at time ${time + 1}`);
          if (lastBlock) {
            lastBlock.querySelector('.gantt-time-label').textContent = time + 1;
            lastBlock = null;
          }
        }
        time++;
        setTimeout(scheduleNext, 300 + contextSwitchDelay);
      }
      scheduleNext();
    }

    function runRR(processes, quantum, contextSwitchDelay) {
      const gantt = document.getElementById("ganttChart");
      const current = document.getElementById("currentProcessBar");
      const outputTable = document.querySelector("#outputTable tbody");
      let n = processes.length;
      let time = 0;
      let completed = 0;
      let queue = [];
      let isInQueue = Array(n).fill(false);
      let isStarted = Array(n).fill(false);
      let totalTAT = 0;
      let totalRT = 0;
      let lastPid = null;
      let lastBlock = null;
      let lastProcessCompleted = false; // Track if the last process completed
      let results = [];
      
      function scheduleNext() {
        if (simulationStopped) return;
        for (let i = 0; i < n; i++) {
          if (!isInQueue[i] && !processes[i].ct && processes[i].at <= time) {
            queue.push(i);
            isInQueue[i] = true;
          }
        }
        if (queue.length === 0) {
          if (completed === n) {
            document.getElementById("avgTAT").textContent = (totalTAT / n).toFixed(2);
            document.getElementById("avgRT").textContent = (totalRT / n).toFixed(2);
            lastSimulationData = {
              gantt: gantt.innerHTML,
              table: results,
              avgTAT: (totalTAT / n).toFixed(2),
              avgRT: (totalRT / n).toFixed(2)
            };
            return;
          }
          time++;
          setTimeout(scheduleNext, 200);
          return;
        }
        const idx = queue.shift();
        const p = processes[idx];
        if (!isStarted[idx]) {
          p.startTime = time;
          isStarted[idx] = true;
          logExec(`Process ${p.pid} started at time ${time}`);
        } else if (lastPid !== p.pid && !lastProcessCompleted) {
          logExec(`Process ${lastPid} preempted at time ${time}, ${p.pid} resumed`);
        }
        if (lastPid !== p.pid) {
          if (lastBlock) {
            lastBlock.querySelector('.gantt-time-label').textContent = time;
          }
          const ganttWrapper = document.createElement("div");
          ganttWrapper.className = "gantt-bar-wrapper";
          ganttWrapper.style.width = "30px";
          ganttWrapper.style.position = "relative";
          ganttWrapper.style.display = "inline-block";
          ganttWrapper.style.verticalAlign = "top";
          const ganttBlock = document.createElement("div");
          ganttBlock.className = "gantt-bar";
          ganttBlock.textContent = p.pid;
          ganttBlock.style.backgroundColor = getColorForPID(p.pid);
          ganttBlock.style.width = "100%";
          ganttWrapper.appendChild(ganttBlock);
          // Time label at right edge, initially empty, will be set on preemption or completion
          const timeLabel = document.createElement("div");
          timeLabel.className = "gantt-time-label";
          timeLabel.textContent = "";
          timeLabel.style.right = "0";
          timeLabel.style.left = "auto";
          timeLabel.style.width = "max-content";
          timeLabel.style.position = "absolute";
          timeLabel.style.bottom = "-18px";
          timeLabel.style.transform = "none";
          timeLabel.style.textAlign = "right";
          ganttWrapper.appendChild(timeLabel);
          gantt.appendChild(ganttWrapper);
          lastPid = p.pid;
          lastBlock = ganttWrapper;
        }
        current.innerHTML = "";
        const label = document.createElement("div");
        label.className = "bar-label";
        label.textContent = p.pid;
        const bar = document.createElement("div");
        bar.className = "bar";
        bar.textContent = p.pid;
        current.appendChild(label);
        current.appendChild(bar);
        let exec = Math.min(quantum, p.remaining);
        for (let t = 0; t < exec; t++) {
          time++;
          for (let i = 0; i < n; i++) {
            if (!isInQueue[i] && !processes[i].ct && processes[i].at <= time) {
              queue.push(i);
              isInQueue[i] = true;
            }
          }
        }
        p.remaining -= exec;
        if (p.remaining === 0) {
          p.ct = time;
          const tat = p.ct - p.at;
          const rt = p.startTime - p.at;
          totalTAT += tat;
          totalRT += rt;
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${p.pid}</td>
            <td>${p.at}</td>
            <td>${p.bt}</td>
            <td>${p.ct}</td>
            <td>${tat}</td>
            <td>${rt}</td>
          `;
          outputTable.appendChild(row);
          completed++;
          logExec(`Process ${p.pid} completed at time ${time}`);
          lastProcessCompleted = true; // Mark that this process completed
          if (lastBlock) {
            lastBlock.querySelector('.gantt-time-label').textContent = time;
            lastBlock = null;
          }
        } else {
          queue.push(idx);
          lastProcessCompleted = false; // Mark that this process was preempted
        }
        setTimeout(scheduleNext, 500);
      }
      scheduleNext();
    }

    function runMLFQ(processes, quantums, allotments, contextSwitchDelay) {
      const gantt = document.getElementById("ganttChart");
      const current = document.getElementById("currentProcessBar");
      const outputTable = document.querySelector("#outputTable tbody");

      let n = processes.length;
      let time = 0;
      let completed = 0;
      let queues = [[], [], [], []]; // Q0, Q1, Q2, Q3
      let isStarted = Array(n).fill(false);
      let totalTAT = 0;
      let totalRT = 0;
      let lastPid = null;
      let lastBlock = null;
      let results = [];

      // For each process, track: current queue, remaining allotment per queue, and if it's in any queue
      let procState = processes.map((p, i) => ({
        queue: 0,
        allotment: [allotments[0], allotments[1], allotments[2], allotments[3]],
        inQueue: [false, false, false, false],
        firstStartTime: null // Track the very first time the process starts
      }));

      function addToQueue(idx, level) {
        if (!procState[idx].inQueue[level]) {
          queues[level].push(idx);
          procState[idx].inQueue[level] = true;
          procState[idx].queue = level;
        }
      }

      function removeFromQueue(idx, level) {
        procState[idx].inQueue[level] = false;
      }

      function getNextProcess() {
        for (let level = 0; level < 4; level++) {
          if (queues[level].length > 0) {
            const idx = queues[level].shift();
            removeFromQueue(idx, level);
            return { idx, level };
          }
        }
        return null;
      }

      function scheduleNext() {
        if (simulationStopped) return;

        // Add newly arrived processes to Q0
        for (let i = 0; i < n; i++) {
          if (!processes[i].ct && processes[i].at <= time && !procState[i].inQueue[0] && !procState[i].inQueue[1] && !procState[i].inQueue[2] && !procState[i].inQueue[3]) {
            addToQueue(i, 0);
            logExec(`Process ${processes[i].pid} arrived at time ${time}, added to Q0`);
          }
        }

        // Get next process to execute
        const next = getNextProcess();

        if (!next) {
          if (completed === n) {
            document.getElementById("avgTAT").textContent = (totalTAT / n).toFixed(2);
            document.getElementById("avgRT").textContent = (totalRT / n).toFixed(2);
            lastSimulationData = {
              gantt: gantt.innerHTML,
              table: results,
              avgTAT: (totalTAT / n).toFixed(2),
              avgRT: (totalRT / n).toFixed(2)
            };
            logExec(`=== SIMULATION COMPLETE ===`);
            logExec(`Total TAT: ${totalTAT}, Total RT: ${totalRT}, Processes: ${n}`);
            logExec(`Average TAT: ${(totalTAT / n).toFixed(2)}, Average RT: ${(totalRT / n).toFixed(2)}`);
            return;
          }
          time++;
          setTimeout(scheduleNext, 200);
          return;
        }

        const { idx, level } = next;
        const p = processes[idx];

        // Mark process as started if first time
        if (!isStarted[idx]) {
          p.startTime = time;
          procState[idx].firstStartTime = time;
          isStarted[idx] = true;
          logExec(`Process ${p.pid} FIRST STARTED at time ${time} in Q${level} (RT will be ${time - p.at})`);
        } else if (lastPid !== p.pid) {
          logExec(`Process ${lastPid} preempted at time ${time}, ${p.pid} resumed in Q${level}`);
        }

        // Create Gantt block
        if (lastPid !== p.pid) {
          if (lastBlock) {
            lastBlock.querySelector('.gantt-time-label').textContent = time;
          }
          const ganttWrapper = document.createElement("div");
          ganttWrapper.className = "gantt-bar-wrapper";
          ganttWrapper.style.width = "30px";
          ganttWrapper.style.position = "relative";
          ganttWrapper.style.display = "inline-block";
          ganttWrapper.style.verticalAlign = "top";
          const ganttBlock = document.createElement("div");
          ganttBlock.className = "gantt-bar";
          ganttBlock.textContent = p.pid + "(Q" + level + ")";
          ganttBlock.style.backgroundColor = getColorForPID(p.pid);
          ganttBlock.style.width = "100%";
          ganttWrapper.appendChild(ganttBlock);
          // Time label at right edge, initially empty, will be set on preemption or completion
          const timeLabel = document.createElement("div");
          timeLabel.className = "gantt-time-label";
          timeLabel.textContent = "";
          timeLabel.style.right = "0";
          timeLabel.style.left = "auto";
          timeLabel.style.width = "max-content";
          timeLabel.style.position = "absolute";
          timeLabel.style.bottom = "-18px";
          timeLabel.style.transform = "none";
          timeLabel.style.textAlign = "right";
          ganttWrapper.appendChild(timeLabel);
          gantt.appendChild(ganttWrapper);
          lastPid = p.pid;
          lastBlock = ganttWrapper;
        }

        // Update current process display
        current.innerHTML = "";
        const label = document.createElement("div");
        label.className = "bar-label";
        label.textContent = p.pid + " (Q" + level + ")";
        const bar = document.createElement("div");
        bar.className = "bar";
        bar.textContent = p.pid;
        current.appendChild(label);
        current.appendChild(bar);

        // Determine execution time
        let exec;
        if (level < 4) {
          exec = Math.min(quantums[level], p.remaining, procState[idx].allotment[level]);
        } else {
          exec = p.remaining;
        }

        // Simulate execution, but preempt if a new process arrives in a higher queue
        let actualExec = 0;
        for (let t = 0; t < exec; t++) {
          time++;
          actualExec++;
          // Check for new arrivals and preempt if needed
          let preempt = false;
          for (let i = 0; i < n; i++) {
            if (!processes[i].ct && processes[i].at === time && !procState[i].inQueue[0] && !procState[i].inQueue[1] && !procState[i].inQueue[2] && !procState[i].inQueue[3]) {
              addToQueue(i, 0);
              logExec(`Process ${processes[i].pid} arrived at time ${time}, added to Q0`);
              if (level > 0) {
                preempt = true; // Preempt if running in lower queue
                break;
              }
            }
          }
          if (preempt) break;
        }

        p.remaining -= actualExec;
        if (level < 4) {
          procState[idx].allotment[level] -= actualExec;
        }

        if (p.remaining === 0) {
          // Process completed
          p.ct = time;
          const tat = p.ct - p.at;
          const rt = procState[idx].firstStartTime - p.at;
          totalTAT += tat;
          totalRT += rt;

          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${p.pid}</td>
            <td>${p.at}</td>
            <td>${p.bt}</td>
            <td>${p.ct}</td>
            <td>${tat}</td>
            <td>${rt}</td>
          `;
          outputTable.appendChild(row);
          completed++;
          logExec(`Process ${p.pid} completed at time ${time} - TAT: ${tat}, RT: ${rt} (First start: ${procState[idx].firstStartTime})`);
          if (lastBlock) {
            lastBlock.querySelector('.gantt-time-label').textContent = time;
            lastBlock = null;
          }
        } else if (level < 4 && procState[idx].allotment[level] === 0) {
          // Allotment exhausted, demote to next queue
          const nextLevel = level + 1;
          if (nextLevel < 4) {
            procState[idx].allotment[nextLevel] = allotments[nextLevel];
            addToQueue(idx, nextLevel);
            logExec(`Process ${p.pid} demoted from Q${level} to Q${nextLevel} at time ${time} (allotment exhausted)`);
          } else {
            // If Q3 allotment is exhausted, keep it in Q3 (FCFS behavior)
            addToQueue(idx, 3);
            logExec(`Process ${p.pid} Q3 allotment exhausted at time ${time}, kept in Q3`);
          }
        } else if (level < 4 && actualExec === quantums[level] && procState[idx].allotment[level] > 0) {
          // Time quantum expired but allotment not exhausted, requeue at same level
          addToQueue(idx, level);
          logExec(`Process ${p.pid} time quantum expired in Q${level} at time ${time}, requeued`);
        } else if (level === 3 && procState[idx].allotment[level] > 0) {
          // Q3 (FCFS), requeue at Q3 if allotment not exhausted
          addToQueue(idx, 3);
        } else if (actualExec < exec) {
          // Preempted by new arrival, requeue at same level
          addToQueue(idx, level);
          logExec(`Process ${p.pid} preempted by new arrival at time ${time}, requeued in Q${level}`);
        }

        setTimeout(scheduleNext, 500);
      }

      scheduleNext();
    }

    function stopSimulation() {
      simulationStopped = true;
    }

    function resetSimulation() {
      simulationStopped = true;
      setTimeout(() => {
      location.reload();
      }, 200);
    }

    function exportResults() {
      const format = document.getElementById("exportFormat").value;
      if (!lastSimulationData) {
        alert("Please run a simulation first.");
        return;
      }
      if (format === "csv") {
        exportCSV(lastSimulationData);
      } else if (format === "txt") {
        exportTXT(lastSimulationData);
      } else if (format === "img") {
        exportImage();
      }
    }

    function exportCSV(data) {
      let csv = 'PID,AT,BT,CT,TAT,RT\n';
      data.table.forEach(row => {
        csv += `${row.pid},${row.at},${row.bt},${row.ct},${row.tat},${row.rt}\n`;
      });
      csv += `Average TAT,${data.avgTAT}\nAverage RT,${data.avgRT}\n`;
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'simulation_results.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportTXT(data) {
      let txt = 'CPU Scheduling Simulation Results\n\n';
      txt += 'PID\tAT\tBT\tCT\tTAT\tRT\n';
      data.table.forEach(row => {
        txt += `${row.pid}\t${row.at}\t${row.bt}\t${row.ct}\t${row.tat}\t${row.rt}\n`;
      });
      txt += `\nAverage TAT: ${data.avgTAT}\nAverage RT: ${data.avgRT}\n`;
      const blob = new Blob([txt], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'simulation_results.txt';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportImage() {
      const ganttBox = document.querySelector('.gantt-chart-box');
      if (window.html2canvas) {
        html2canvas(ganttBox).then(canvas => {
          const link = document.createElement('a');
          link.download = 'gantt_chart.png';
          link.href = canvas.toDataURL();
          link.click();
        });
      } else {
        alert('Image export requires html2canvas library.');
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById("numProcesses").addEventListener("input", toggleInputType);
      document.querySelectorAll('input[name="inputType"]').forEach(radio => {
        radio.addEventListener("change", toggleInputType);
      });
      toggleInputType();
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</body>
</html> 
